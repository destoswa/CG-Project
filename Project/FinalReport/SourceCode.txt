================================================================== 
======================= MOVEMENTS ===============================
==================================================================


===== FIRST PERSON CONTROLER =====
 
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class FPC : MonoBehaviour
{
    private Rigidbody rb;
    public bool doControl = true;
    #region Camera Movement Variables
    public Camera playerCamera;
    public float mouseSensitivity = 3f;
    public float maxLookAngle = 90f;
    //Internal Variables
    private float yaw = 0.0f;
    private float pitch = 0.0f;
    #endregion

    #region Movement
    public float moveSpeed = 10f;
    public float maxVelocityChange = 7f;
    #endregion
    
    private Vector3 velPlayer;
    
    // Start is called before the first frame update
    void Start()
    {
        Cursor.lockState = CursorLockMode.Locked;
        rb = GetComponent<Rigidbody>();
    }

    // Update is called once per frame
    void Update()
    {
        if(doControl){
            // Rotation
            yaw = transform.localEulerAngles.y + Input.GetAxis("Mouse X") * mouseSensitivity;
            pitch = pitch - Input.GetAxis("Mouse Y") * mouseSensitivity;
            pitch = Mathf.Clamp(pitch, -maxLookAngle, maxLookAngle);
            transform.localEulerAngles = new Vector3(0, yaw, 0);
            playerCamera.transform.localEulerAngles = new Vector3(pitch, 0,0);
        }
    }

    // FixedUpdate is called every fixed frame-rate frame (used for physics implementation)
    private void FixedUpdate()
    {
        Vector3 targetVelocity = new Vector3(Input.GetAxis("Horizontal"),0,Input.GetAxis("Vertical"));
        targetVelocity = transform.TransformDirection(targetVelocity) * moveSpeed;

        // Apply the changes in velocity
        Vector3 velocityChange = targetVelocity - rb.velocity;
        velocityChange.x = Mathf.Clamp(velocityChange.x, -maxVelocityChange, maxVelocityChange);
        velocityChange.z = Mathf.Clamp(velocityChange.z, -maxVelocityChange, maxVelocityChange);
        velocityChange.y = 0;
        rb.AddForce(velocityChange, ForceMode.VelocityChange);

        // Gravity management
        #region Gravity
        Vector3 gravity = new Vector3(0,-9.81f,0);
        float gravityMultiplayer = 10f;
        gravity *= gravityMultiplayer;

        if(rb.velocity.y < 0)
        {
            rb.AddForce(gravity, ForceMode.Force);
        }
        #endregion
    }

    // Collisions management
    private void OnCollisionEnter(Collision collision)
    {
        print(collision.gameObject.name);
        print(collision.transform.rotation.eulerAngles);
        velPlayer = rb.velocity;
        rb.angularVelocity = new Vector3(0,0,0);
    }

    // Avoid some perturbation effects on collisions with walls
    private void OnCollisionExit(Collision collision)
    {
        print(collision.gameObject.name);
        rb.angularVelocity = new Vector3(0,0,0);
    }

    private void OnCollisionStay(Collision collision)
    {
        if (collision.gameObject.layer == 6){
            rb.angularVelocity = new Vector3(0,0,0);
        }
    }
}


===== lOOK AT TARGET =====

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class LookAtTarget : MonoBehaviour
{
    public GameObject Target;
    public Camera playerCamera;
    public float Speed = 1f;
    public bool DoLookAt = false;

    private Coroutine LookCoroutine;

    
    public void Update()
    {
        if(DoLookAt == true){
            Quaternion lookRotation = Quaternion.LookRotation(Target.transform.position - transform.position);
            transform.rotation = Quaternion.Slerp(transform.rotation, lookRotation, Time.deltaTime * Speed);
            playerCamera.transform.rotation = Quaternion.Slerp(playerCamera.transform.rotation,transform.rotation, Time.deltaTime * Speed);
        }
    }
}


===== FOLLOW TARGET =====

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class FollowTarget : MonoBehaviour
{
    private Rigidbody rb;
    private float aimSpeed;
    public bool DoFollow = false;
    public GameObject lookat;
    public float Force = 2.5f;
    public float coeff_repeal = 5.0f;
    public float coeff_fluid = 1.0f;

    // Start is called before the first frame update
    void Start()
    {
        rb = GetComponent<Rigidbody>();
        aimSpeed = lookat.GetComponent<TargetFollowPath>().aimSpeed;
    }

    // Update is called once per frame
    void Update()
    {
        Vector3 deltaPos = lookat.transform.position - transform.position;
        Vector3 speed = rb.velocity.normalized * Mathf.Pow(rb.velocity.magnitude,2);
        float distance = deltaPos.magnitude;
        Vector3 direction = deltaPos.normalized;

        // Different forces applied to the player while following the target
        Vector3 forceAttract = deltaPos * Force;
        Vector3 forceRepeal = -direction / distance * coeff_repeal;
        Vector3 forceFluid = -speed * coeff_fluid;
        Vector3 forceApplied = forceAttract + forceRepeal + forceFluid;
        forceApplied.y = 0f;
        if(DoFollow){
            rb.AddForce(forceApplied, ForceMode.Force);
        }
    }
}


===== CONTROL DURING GAME =====

using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;


public class ControlDuringGame : MonoBehaviour
{
    public ControlPoints controlpoints;
    public GameObject lookat;
    public Camera playerCamera;
    private float aimSpeed;
    private FollowTarget cinematic;
    private FPC fpc;
    private Rigidbody rb;
    private LookAtTarget focusOn;

    // Start is called before the first frame update
    void Start()
    {
        cinematic = GetComponent<FollowTarget>();
        rb = GetComponent<Rigidbody>();
        aimSpeed = lookat.GetComponent<TargetFollowPath>().aimSpeed;
        fpc = GetComponent<FPC>();
        focusOn = GetComponent<LookAtTarget>();
    }

    // Update is called once per frame
    void Update()
    {
        if (Input.GetKeyDown("space"))
        {
            if (cinematic.DoFollow == false)
            {
                // Bring Target close to the player
                DragTargetBack();

                // follow the target
                cinematic.DoFollow = true;

                // Look at target
                focusOn.DoLookAt = true;
            }
            else
            {
                // Stop following the target
                cinematic.DoFollow = false;
                rb.velocity = new Vector3(0,0,0);
                
                // Enable First Person Controller
                fpc.enabled = true;
                focusOn.DoLookAt = false;
            }
        }
    }

    private void DragTargetBack()
    {
        // Disable first person controller and stop motion
        fpc.enabled = false;
        rb.velocity = new Vector3(0f, 0f, 0f);

        // get all the positions on the path
        List<Vector3> PathPoints = new List<Vector3>();
        for (int i = 0; i < controlpoints.transform.childCount - 3; i = i + 3)
        {
            for (float t = 0; t <= 1; t += 0.01f)
            {
                Vector3 newPosition = Mathf.Pow(1 - t, 3) * controlpoints.transform.GetChild(i).position +
                3 * Mathf.Pow(1 - t, 2) * t * controlpoints.transform.GetChild(i + 1).position +
                3 * (1 - t) * Mathf.Pow(t, 2) * controlpoints.transform.GetChild(i + 2).position +
                Mathf.Pow(t, 3) * controlpoints.transform.GetChild(i + 3).position;

                PathPoints.Add(newPosition);
            }
        }

        // Find closest position
        float MinDist = (transform.position - PathPoints[0]).magnitude;
        Vector3 MinPos = PathPoints[0];
        foreach (Vector3 pos in PathPoints){
            float dist = (transform.position - pos).magnitude;
            if (dist < MinDist){
                MinDist = dist;
                MinPos = pos;
            }
        }

        // Find Real position
        float RealDist = MinDist;
        Vector3 RealPos = MinPos;
        float AimDistance = 4f;
        for (int i = 0; i < PathPoints.Count; i++){
            if (PathPoints[i] == RealPos){
                float dist = (PathPoints[i] - transform.position).magnitude;
                while(dist < AimDistance){
                    dist = (PathPoints[i] - transform.position).magnitude;
                    RealPos = PathPoints[i];
                    RealDist = dist;
                    i++;
                    if (i == PathPoints.Count){i = 0;}
                }
                break;
            }
        }

        // Find the parameters tparam and routeToGo corresponding to the closest position
        int NewRouteToGo = 0;
        float NewtParam = 0f;
        for (int i = 0; i < controlpoints.transform.childCount - 3; i = i + 3)
        {
            for (float t = 0; t <= 1; t += 0.01f)
            {
                Vector3 newPosition = Mathf.Pow(1 - t, 3) * controlpoints.transform.GetChild(i).position +
                3 * Mathf.Pow(1 - t, 2) * t * controlpoints.transform.GetChild(i + 1).position +
                3 * (1 - t) * Mathf.Pow(t, 2) * controlpoints.transform.GetChild(i + 2).position +
                Mathf.Pow(t, 3) * controlpoints.transform.GetChild(i + 3).position;

                if (newPosition == RealPos){
                    NewRouteToGo = i;
                    NewtParam = t;
                }
            }
        }

        // Move the target
        lookat.GetComponent<TargetFollowPath>().jump = true;
        lookat.GetComponent<TargetFollowPath>().routeToGo = NewRouteToGo;
        lookat.GetComponent<TargetFollowPath>().tParam = NewtParam;
    }
}


================================================================== 
======================= BEZIER CURVES ============================
==================================================================

===== CONTROL POINTS =====
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class ControlPoints : MonoBehaviour
{

    [Range(0f, 2f)]
    [SerializeField] private float controllSize = 1f;

    [Range(0f, 1f)]
    [SerializeField] private float curveSize = 0.25f;

    private Vector3 gizmosPosition;

    private void OnDrawGizmos()
    {
        foreach(Transform t in transform)
        {
            Gizmos.color = Color.blue;
            Gizmos.DrawWireSphere(t.position, controllSize);
        }
        Color tmp = Color.gray;
        tmp.a = 0.5f;
        Gizmos.color = tmp;

        // Loop on every child of the object
        for (int i = 0; i < transform.childCount - 3; i = i + 3)
        {
            // For every pack of 3 children, build a Bezier curve using gizmos objects
            for (float t = 0; t <= 1; t += 0.01f)
            {
                gizmosPosition = Mathf.Pow(1 - t, 3) * transform.GetChild(i).position +
                3 * Mathf.Pow(1 - t, 2) * t * transform.GetChild(i + 1).position +
                3 * (1 - t) * Mathf.Pow(t, 2) * transform.GetChild(i + 2).position +
                Mathf.Pow(t, 3) * transform.GetChild(i + 3).position;
                Gizmos.DrawSphere(gizmosPosition, curveSize);
            }
            Gizmos.DrawLine(transform.GetChild(i).position, transform.GetChild(i + 1).position);
            Gizmos.DrawLine(transform.GetChild(i + 2).position, transform.GetChild(i + 3).position);
        }

    }
}


===== TARGET FOLLOW PATH =====

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class TargetFollowPath : MonoBehaviour
{
    public ControlPoints controlpoints;

    public int routeToGo;

    public float tParam;

    private Vector3 playerPosition;

    public float speedModifier = 0.5f;

    public float aimSpeed = 20f;

    public bool coroutineAllowed;

    public bool jump = false;

    // Start is called before the first frame update
    void Start()
    {
        routeToGo = 0;
        tParam = 0f;
        coroutineAllowed = true;
    }

    // Update is called once per frame
    void Update()
    {
        if (coroutineAllowed)
        {
            StartCoroutine(GoByTheRoute(routeToGo));
        }  
    }

    private IEnumerator GoByTheRoute(int routeNumber)
    {
        coroutineAllowed = false;

        Vector3 p0 = controlpoints.transform.GetChild(routeNumber).position;
        Vector3 p1= controlpoints.transform.GetChild(routeNumber + 1).position;
        Vector3 p2 = controlpoints.transform.GetChild(routeNumber + 2).position;
        Vector3 p3 = controlpoints.transform.GetChild(routeNumber + 3).position;

        while (tParam < 1.0)
        {
            // Find the new position if the target jump to the nearest position from the player
            if (jump){
                p0 = controlpoints.transform.GetChild(routeToGo).position;
                p1 = controlpoints.transform.GetChild(routeToGo + 1).position;
                p2 = controlpoints.transform.GetChild(routeToGo + 2).position;
                p3 = controlpoints.transform.GetChild(routeToGo + 3).position;
                jump = false;
            }
               
            float prevtParam = tParam;
            tParam += Time.deltaTime * speedModifier;

            // Compute a first time the next position
            playerPosition = Mathf.Pow(1 - tParam, 3) * p0 +
            3 * Mathf.Pow(1 - tParam, 2) * tParam * p1 +
            3 * (1 - tParam) * Mathf.Pow(tParam, 2) * p2 +
            Mathf.Pow(tParam, 3) * p3;

            // Find the difference between the speed and the aimed speed and change tParam in order to keep the constant speed
            float speed = (transform.position - playerPosition).magnitude / (Time.deltaTime * speedModifier);
            float alpha = aimSpeed / speed;
            tParam = prevtParam + (Time.deltaTime * speedModifier) * alpha;

            // Recompute the next position
            playerPosition = Mathf.Pow(1 - tParam, 3) * p0 +
            3 * Mathf.Pow(1 - tParam, 2) * tParam * p1 +
            3 * (1 - tParam) * Mathf.Pow(tParam, 2) * p2 +
            Mathf.Pow(tParam, 3) * p3;
            
            Vector3 distance = (playerPosition - transform.position) / (playerPosition - transform.position).magnitude * 10;
            transform.position = playerPosition;
            yield return new WaitForEndOfFrame();
        }

        tParam = 0f;
        routeToGo += 3;

        if (routeToGo > controlpoints.transform.childCount - 3)
        {
            routeToGo = 0;
        }

        coroutineAllowed = true;
    }
}


================================================================== 
======================= FOCUS ZONES ==============================
==================================================================


===== FOCUS ZONE (APPLIED TO PLAYER) =====

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class FocusZone : MonoBehaviour
{
    public GameObject Target;
    public float SpeedWhileFocus = 1.5f;
    public float SpeedChangeOfSight = 1f;

    private TargetFollowPath targetfollowpath;
    private LookAtTarget lookattarget;
    private GameObject oldTarget;
    private float oldSpeed;
    private float oldSpeedChangeOfSight;

    // Start is called before the first frame update
    void Start()
    {
        lookattarget = GetComponent<LookAtTarget>();
        oldTarget = lookattarget.Target;
        targetfollowpath = Target.GetComponent<TargetFollowPath>();
        oldSpeed = targetfollowpath.aimSpeed;
        oldSpeedChangeOfSight = lookattarget.Speed;
    }

    private void OnTriggerStay(Collider collider)
    {
        if (collider.gameObject.layer == 7 && collider.name == "FocusZonePlayer"){
            // Change the object to look at (and the speed at which it turns if necessary)
            lookattarget.Target = collider.transform.parent.GetChild(0).gameObject;
            lookattarget.Speed = SpeedChangeOfSight;

            // Change the speed of the target
            targetfollowpath.aimSpeed = SpeedWhileFocus;
        }
    }

    private void OnTriggerExit(Collider collider)
    {
        if (collider.gameObject.layer == 7 && collider.name == "FocusZonePlayer"){

            // Reset the normal values
            lookattarget.Target = oldTarget;
            targetfollowpath.aimSpeed = oldSpeed;
            lookattarget.Speed = oldSpeedChangeOfSight;
        }
    }
}


===== TARGET ENTER FOCUS ZONE =====

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class TargetEnterFocusZone : MonoBehaviour
{
    public float SpeedWhileFocus = 1.5f;
    private TargetFollowPath followPath;
    private float oldSpeed;

    // Start is called before the first frame update
    void Start()
    {
        followPath = GetComponent<TargetFollowPath>();
        oldSpeed = followPath.aimSpeed;
    }

    private void OnTriggerStay(Collider collider)
    {
        if (collider.gameObject.layer == 7 && collider.name == "FocusZoneTarget"){
            followPath.aimSpeed = SpeedWhileFocus;
        }
    }

    private void OnTriggerExit(Collider collider)
    {
        if (collider.gameObject.layer == 7){
            followPath.aimSpeed = oldSpeed;
        }
    }
}


================================================================== 
======================= CAULDRON ===============================
==================================================================


===== CAULDRON SHADER =====

Shader "Custom/CauldronShader"
{
    Properties
    {
        _Color ("Color", Color) = (1,1,1,1)
        _MainTex ("Albedo (RGB)", 2D) = "white" {}
        _Glossiness ("Smoothness", Range(0,1)) = 0.5
        _Metallic ("Metallic", Range(0,1)) = 0.0
        _Alpha ("Alpha", Range(0,1)) = 0.8
        _Amplitude ("WaveSize", Range(0,1)) = 0.4
        _Frequency ("WaveFrequency", Range(1,8)) = 2
        _Speed("Speed", Range(-200,200)) = 100
        _MaxRange("MaxRange",Range(-200,200)) = 1.0
    }
    SubShader
    {
        Tags {"RenderType"="Transparent"}

        LOD 200

        CGPROGRAM
        // Physically based Standard lighting model, and enable shadows on all light types
        #pragma surface surf Standard fullforwardshadows vertex:vert addshadow 

        // Use shader model 3.0 target, to get nicer looking lighting
        #pragma target 3.0

        sampler2D _MainTex;

        struct Input
        {
            float2 uv_MainTex;
        };

        half _Glossiness;
        half _Metallic;
        half _Alpha;
        fixed4 _Color;
        float _Amplitude;
        float _Frequency;
        float _Speed;
        float _MaxRange;


        // Add instancing support for this shader. You need to check 'Enable Instancing' on materials that use the shader.
        // See https://docs.unity3d.com/Manual/GPUInstancing.html for more information about instancing.
        // #pragma instancing_options assumeuniformscaling
        UNITY_INSTANCING_BUFFER_START(Props)
            // put more per-instance properties here
        UNITY_INSTANCING_BUFFER_END(Props)
        
        // Modification of the origin vertex to make the animation
        float Modification (float3 originVec){
            float norm = length(originVec);
            float3 modifiedPos = originVec;
            float3 worldPos = mul(unity_ObjectToWorld, modifiedPos);
            float3 objectOrigin = mul(unity_ObjectToWorld, float3(0,0,0));
            float distance = sqrt(pow(worldPos.x - objectOrigin.x,2.0) + pow(worldPos.z - objectOrigin.z,2.0));
            float3 worldPosRelCenter = worldPos - objectOrigin;
            float r = sqrt(pow(worldPosRelCenter.x,2.0) + pow(worldPosRelCenter.z,2.0));
            float phi = atan2(worldPosRelCenter.x,worldPosRelCenter.z);

            // Different possible paterns that the surface can use (the parameters of the shader need to be adjusted for each displacement)
            
            //float4 displacement = (cos(_Frequency*(r + (_Speed * _Time)))) * (1 - distance/_MaxRange) * exp(1 + distance/_MaxRange);//Pos 1
            //float4 displacement = (2*cos(_Frequency*(r + (0.1*_Speed * _Time))) + cos(_Frequency*(r + (_Speed * _Time)))) * (1 - distance/_MaxRange) * exp(1 + distance/_MaxRange);//Pos 2
            float displacement = 0.001*_Amplitude*(cos(_Frequency*3*(r + (_Speed * _Time))) + cos(_Frequency*(phi*10 + (_Speed * _Time)))) * (1 - distance/_MaxRange) *exp(1 + distance/_MaxRange);    //Pos 3
            //float4 displacement = (cos(_Frequency*r + phi + _Speed * _Time)) * (1 - distance/_MaxRange) *exp(1 + distance/_MaxRange);    //Pos 4
            return displacement;
        }

        // New vertex shader
        void vert(inout appdata_full data){
            // Modification
            float3 modifiedPos = data.vertex.xyz;
            modifiedPos.z += Modification(modifiedPos);

            // Modification of Tangent and Bitangent
            float3 posPlusTangent = data.vertex.xyz + data.tangent * 0.01;
            posPlusTangent.z = Modification(posPlusTangent);

            float3 bitangent = cross(data.normal, data.tangent);
            float3 posPlusBitangent = data.vertex.xyz + bitangent * 0.01;
            posPlusBitangent.z = Modification(posPlusBitangent);

            float3 modifiedTangent = posPlusTangent - modifiedPos;
            float3 modifiedBiTangent = posPlusBitangent - modifiedPos;

            //Modification of normal
            float3 modifiedNormal = cross(modifiedTangent,modifiedBiTangent);

            // Application of modification
            data.normal = normalize(modifiedNormal);
            data.vertex.xyz = modifiedPos + 0.0001;
        }

        void surf (Input IN, inout SurfaceOutputStandard o)
        {
            // Albedo comes from a texture tinted by color
            fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;
            c.a = _Alpha;
            o.Albedo = c.rgb;
            // Metallic, transparency and smoothness come from slider variables
            o.Metallic = _Metallic;
            o.Smoothness = _Glossiness;
            o.Alpha = c.a;
        }
        ENDCG
    }
    FallBack "Diffuse"
}


================================================================== 
======================= LIGHTNING ================================
==================================================================


===== LIGHTNING EFFECT =====
 
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class LightningEffect : MonoBehaviour
{
    public Material LightingMaterial;
    public GameObject PreFab;
    public GameObject particlePreFab;
    [Range(1,10)]
    public float Distance = 8f;
    [Range(0.1f,5f)]
    public float Frequence = 1f;
    public float numLigthnings = 5f;
    public int meanNumAngles = 10;
    public float widenessOfLightning = 1.5f;
    public float chancesOfSplit = 0.05f;


    private List<ParticleSystemBehaviour> aliveSystems = new List<ParticleSystemBehaviour>();

    
    void Start()
    {
        StartCoroutine("ShowLines");
    }


    void Update()
    {
        aliveSystems.RemoveAll(system => system == null);
        for (int i = 0; i < aliveSystems.Count; i++) {
            ParticleSystemBehaviour system = aliveSystems[i];
            system.Update();
        }
    }

    private IEnumerator ShowLines(){
        Vector3 center = transform.position;
        float xDim = transform.localScale.x*5f;
        float zDim = transform.localScale.z*5f;
        while(true){

            int randomNumLightings = (int) (numLigthnings*(1 + 0.5*UnityEngine.Random.Range(-1, 1))) ;
            for(int i = 0; i < randomNumLightings; i++){
                Vector3 pos = new Vector3(center.x + UnityEngine.Random.Range(-xDim, xDim), center.y,center.z + UnityEngine.Random.Range(-zDim, zDim));

                //Creating gameObjects
                GameObject go = new GameObject("Lightning_" + i.ToString());
                go.transform.parent = this.transform;
                LineRenderer lr = go.AddComponent(typeof(LineRenderer)) as LineRenderer;
                lr.startWidth = 0.05f;
                lr.endWidth = 0.05f;
                lr.material = LightingMaterial;

                // Show gameObject
                StartCoroutine(Show(go, lr, pos));
                yield return new WaitForSeconds(.1f);
            }

            float TimeToWait = 1/Frequence *(1f + 0.5f*UnityEngine.Random.Range(-1f, 1f));
            yield return new WaitForSeconds( TimeToWait );
        }
    }


    private IEnumerator Show(GameObject go,  LineRenderer lr, Vector3 pos){
        SetUpLine(go, lr, pos,new Vector3(0f,1f,0f), meanNumAngles, chancesOfSplit, true);
        yield return new WaitForSeconds(.2f);

        // Destroy game object
        GameObject.Destroy(go);
    }

    private void SetUpLine(GameObject go, LineRenderer lr, Vector3 pos, Vector3 dir, int numAngles, float chancesSplit, bool toGround=false){
        // Number of angles
        int numAnglesRand = (int)UnityEngine.Random.Range(numAngles * 0.8f, numAngles *1.2f);
        lr.positionCount = numAnglesRand + 2;

        // Creating positions
            float[] Positions = new float[numAnglesRand];
            float dist = 0f;
            if(toGround){
                dist = Distance;
            }
            else{
                dist = (Distance - (transform.position.y - pos.y)) * (0.4f + UnityEngine.Random.Range(-0.1f, 0.1f));
            }

            for(int i = 0; i < numAnglesRand; i++){
                Positions[i] = UnityEngine.Random.Range(0, dist);
            }
            
            Array.Sort(Positions);
            
            

        // Creating lines

        // Creating first segment
        lr.SetPosition(0,pos);

        // Creating the n-2 next segments
        for(int i = 0; i< numAnglesRand; i++){
            Vector3 perpVec1 = Vector3.Normalize(Vector3.Cross(dir, new Vector3(1f,1f,1f))) * UnityEngine.Random.Range(-widenessOfLightning/2, widenessOfLightning/2);
            Vector3 perpVec2 = Vector3.Normalize(Vector3.Cross(dir, perpVec1)) * UnityEngine.Random.Range(-widenessOfLightning/2, widenessOfLightning/2);
            Vector3 posAngle = pos - dir * Positions[i] + perpVec1 + perpVec2;
            lr.SetPosition(i+1,posAngle);
            
            // Add child
            if(UnityEngine.Random.value < chancesOfSplit && i >= numAnglesRand/4 && i <= 3*numAnglesRand/4){
                GameObject goChild = new GameObject("Lightning_" + i.ToString());
                goChild.transform.parent = go.transform;
                LineRenderer lrChild = goChild.AddComponent(typeof(LineRenderer)) as LineRenderer;
                lrChild.startWidth = 0.05f;
                lrChild.endWidth = 0.05f;
                lrChild.material = LightingMaterial;

                // Find new direction
                Vector3 vec1 = Vector3.Cross(dir, new Vector3(1f,1f,1f));
                Vector3 NewDir = Vector3.Normalize(Vector3.Cross(dir, vec1));
                SetUpLine(goChild, lrChild, posAngle, NewDir, (int)numAngles/3, chancesOfSplit*0.5f);
            }
        }

        // Creating last segment (on the ground)
        Vector3 perpVecLast1 = Vector3.Normalize(Vector3.Cross(dir, new Vector3(1f,1f,1f))) * UnityEngine.Random.Range(-widenessOfLightning/2, widenessOfLightning/2);
        Vector3 perpVecLast2 = Vector3.Normalize(Vector3.Cross(dir, perpVecLast1)) * UnityEngine.Random.Range(-widenessOfLightning/2, widenessOfLightning/2);
        lr.SetPosition(numAnglesRand+1, pos - dir * dist + perpVecLast1 + perpVecLast2);
        
        //Create Ground effect
        if (toGround){
            ParticleSystemBehaviour newSystem = Instantiate(PreFab, lr.GetPosition(numAnglesRand +1) , Quaternion.identity, go.transform).GetComponent<ParticleSystemBehaviour>();
            newSystem.Initialize(lr.GetPosition(numAnglesRand +1), particlePreFab);
            aliveSystems.Add(newSystem);
        }
    }

}

================================================================== 
======================= PARTICLE SYSTEMS ================================
==================================================================


===== PARTICLE SYSTEM =====

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class ParticleSystemBehaviour : MonoBehaviour
{
    public GameObject particlePrefab;
    public float frequency;
    public enum InitShape {
        Point,
        Rectangle,
        Cube
    } 
    public InitShape initShape;
    // point
    public Vector3 initPos;
    // rectangle
    public float width;
    public float length;
    private Vector3 leftDownCorner;
    private Vector3 rightDownCorner;
    private Vector3 leftUpCorner;
    private Vector3 rightUpCorner;
    // cube
    public float sizeX;
    public float sizeY;
    public float sizeZ;
    private Vector3[] coordinates = new Vector3[8];

    public bool firework;
    public int minLines;
    public int maxLines;
    private Vector3[] directions;
    public bool shouldTimeout;
    public float timeout;
    private float timer = 0f;
    private float frequency_timer = 0f;
    private ParticleBehaviour createParticle(Vector3 position, Vector3 velocity) {
        ParticleBehaviour newParticle = Instantiate(particlePrefab, position, Quaternion.identity).GetComponent<ParticleBehaviour>();
        newParticle.Initialize(position, velocity);
        return newParticle;
    }

    public void Initialize(Vector3 position, GameObject particle) {
        this.initPos = position;
        this.particlePrefab = particle;
    }

    private List<ParticleBehaviour> aliveParticles = new List<ParticleBehaviour>();
    // Start is called before the first frame update
    void Start()
    {
        frequency *= 0.0000001f;
        if (firework) {
            int nbLines = Random.Range(minLines, maxLines);
            directions = new Vector3[nbLines];
            for (int i = 0; i<nbLines; i++) {
                directions[i] = Random.insideUnitSphere;
            }
        }

        switch (initShape) {
            case InitShape.Point:
                break;
            case InitShape.Rectangle:
                leftDownCorner = new Vector3(transform.position.x - length, transform.position.y, transform.position.z - width);
                rightDownCorner = new Vector3(transform.position.x + length, transform.position.y, transform.position.z - width);
                rightUpCorner = new Vector3(transform.position.x + length, transform.position.y, transform.position.z + width);
                leftUpCorner = new Vector3(transform.position.x - length, transform.position.y, transform.position.z + width);
                break;
            case InitShape.Cube:
                coordinates[0] = new Vector3(transform.position.x - sizeX, transform.position.y - sizeY, transform.position.z - sizeZ);
                coordinates[1] = new Vector3(transform.position.x + sizeX, transform.position.y - sizeY, transform.position.z - sizeZ);
                coordinates[2] = new Vector3(transform.position.x + sizeX, transform.position.y - sizeY, transform.position.z + sizeZ);
                coordinates[3] = new Vector3(transform.position.x - sizeX, transform.position.y - sizeY, transform.position.z + sizeZ);
                coordinates[4] = new Vector3(transform.position.x - sizeX, transform.position.y + sizeY, transform.position.z - sizeZ);
                coordinates[5] = new Vector3(transform.position.x + sizeX, transform.position.y + sizeY, transform.position.z - sizeZ);
                coordinates[6] = new Vector3(transform.position.x + sizeX, transform.position.y + sizeY, transform.position.z + sizeZ);
                coordinates[7] = new Vector3(transform.position.x - sizeX, transform.position.y + sizeY, transform.position.z + sizeZ);
                break;
        }
    }
    // Update is called once per frame
    public void Update()
    {
        if (shouldTimeout) timer += Time.deltaTime;
        frequency_timer += Time.deltaTime;
        if (frequency_timer >= frequency) {
            if (firework & timer < timeout) {
                for (int i = 0; i<directions.Length; i++) {
                    spawnNewParticle(directions[i]);
                }
            }
            else if (shouldTimeout & timer >= timeout) {
                Destroy(gameObject);
            }
            else spawnNewParticle(Vector3.zero);
            frequency_timer = 0f;
        }
        removeDeadParticles();
        updateAliveParticles();
    }

     private void removeDeadParticles() {
        aliveParticles.RemoveAll(particle => particle == null);
    }

    private void updateAliveParticles() {
        for (int i = 0; i < aliveParticles.Count; i++)
        {
            ParticleBehaviour particle = aliveParticles[i];
            particle.Update();
            updateParticleBlend(particle);
        }
    }

    private void spawnNewParticle(Vector3 velocity) {
        ParticleBehaviour newParticle = null;
        switch (initShape) {
            case InitShape.Point:
                newParticle = createParticle(initPos, velocity);
                break;
            case InitShape.Rectangle:
                Vector3 normal = Vector3.Cross(rightDownCorner - leftDownCorner, leftUpCorner - leftDownCorner).normalized;
                float length = Random.Range(0f, 1f);
                float height = Random.Range(0f, 1f);
                Vector3 randomPos = leftDownCorner + length * (rightDownCorner - leftDownCorner) + height * (leftUpCorner - leftDownCorner);
                newParticle = createParticle(randomPos, velocity);
                break;
            case InitShape.Cube:
                // Calculate the minimum and maximum bounds for each axis
                float minX = Mathf.Min(coordinates[0].x, coordinates[1].x, coordinates[2].x, coordinates[3].x, coordinates[4].x, coordinates[5].x, coordinates[6].x, coordinates[7].x);
                float maxX = Mathf.Max(coordinates[0].x, coordinates[1].x, coordinates[2].x, coordinates[3].x, coordinates[4].x, coordinates[5].x, coordinates[6].x, coordinates[7].x);
                float minY = Mathf.Min(coordinates[0].y, coordinates[1].y, coordinates[2].y, coordinates[3].y, coordinates[4].y, coordinates[5].y, coordinates[6].y, coordinates[7].y);
                float maxY = Mathf.Max(coordinates[0].y, coordinates[1].y, coordinates[2].y, coordinates[3].y, coordinates[4].y, coordinates[5].y, coordinates[6].y, coordinates[7].y);
                float minZ = Mathf.Min(coordinates[0].z, coordinates[1].z, coordinates[2].z, coordinates[3].z, coordinates[4].z, coordinates[5].z, coordinates[6].z, coordinates[7].z);
                float maxZ = Mathf.Max(coordinates[0].z, coordinates[1].z, coordinates[2].z, coordinates[3].z, coordinates[4].z, coordinates[5].z, coordinates[6].z, coordinates[7].z);

                // Generate random values within the range of each axis
                float randomX = Random.Range(minX, maxX);
                float randomY = Random.Range(minY, maxY);
                float randomZ = Random.Range(minZ, maxZ);

                // Construct a new point using the generated random values
                Vector3 randomPoint = new Vector3(randomX, randomY, randomZ);

                newParticle = createParticle(randomPoint, velocity);
                break;

        }
        aliveParticles.Add(newParticle);
    }

    private void updateParticleBlend(ParticleBehaviour particle) {
        if (aliveParticles.Count < 2) return;

        float blendDistance = particle.radius;
        for (int i = 0; i < aliveParticles.Count; i++)
        {
            ParticleBehaviour other = aliveParticles[i];
            if (particle == other) continue;

            float distance = Vector3.Distance(particle.transform.position, other.transform.position);
            if (distance <= blendDistance)
            {
                //float blendAmount = 1f - (distance / blendDistance);
                float blendAmount = Mathf.InverseLerp(0, blendDistance, distance);
                particle.Blend(other, blendAmount);
            }
        }
    }
}


===== PARTICLE SYSTEM UNITY EDITOR =====

using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;

[CustomEditor(typeof(ParticleSystemBehaviour))]
public class ParticleSystemBehaviourEditor : Editor
{
    SerializedProperty particlePrefab;
    SerializedProperty frequency;
    SerializedProperty initShape;
    SerializedProperty initPos;
    SerializedProperty width;
    SerializedProperty length;
    SerializedProperty sizeX;
    SerializedProperty sizeY;
    SerializedProperty sizeZ;
    SerializedProperty firework;
    SerializedProperty minLines;
    SerializedProperty maxLines;
    SerializedProperty shouldTimeout;
    SerializedProperty timeout;

    void OnEnable()
    {
        particlePrefab = serializedObject.FindProperty("particlePrefab");
        frequency = serializedObject.FindProperty("frequency");
        initShape = serializedObject.FindProperty("initShape");
        initPos = serializedObject.FindProperty("initPos");
        width = serializedObject.FindProperty("width");
        length = serializedObject.FindProperty("length");
        sizeX = serializedObject.FindProperty("sizeX");
        sizeY = serializedObject.FindProperty("sizeY");
        sizeZ = serializedObject.FindProperty("sizeZ");
        firework = serializedObject.FindProperty("firework");
        minLines = serializedObject.FindProperty("minLines");
        maxLines = serializedObject.FindProperty("maxLines");
        shouldTimeout = serializedObject.FindProperty("shouldTimeout");
        timeout = serializedObject.FindProperty("timeout");

    }

    public override void OnInspectorGUI()
    {
        serializedObject.Update();

        var behaviour = (ParticleSystemBehaviour)target;


        EditorGUILayout.LabelField("General information", EditorStyles.boldLabel);
        EditorGUILayout.PropertyField(particlePrefab);
        EditorGUILayout.PropertyField(frequency);
        EditorGUILayout.PropertyField(initShape);

        if (behaviour.initShape == ParticleSystemBehaviour.InitShape.Point) {
            EditorGUILayout.PropertyField(initPos);
        }
        else if (behaviour.initShape == ParticleSystemBehaviour.InitShape.Rectangle) {
            EditorGUILayout.PropertyField(width);
            EditorGUILayout.PropertyField(length);
        }
        else if (behaviour.initShape == ParticleSystemBehaviour.InitShape.Cube) {
            EditorGUILayout.PropertyField(sizeX);
            EditorGUILayout.PropertyField(sizeY);
            EditorGUILayout.PropertyField(sizeZ);
        }
        EditorGUILayout.PropertyField(firework);
        if (behaviour.firework) {
            EditorGUILayout.PropertyField(minLines);
            EditorGUILayout.PropertyField(maxLines);
            behaviour.shouldTimeout = true;
        }
        EditorGUILayout.PropertyField(shouldTimeout);
        if (behaviour.shouldTimeout) {
            EditorGUILayout.PropertyField(timeout);
        }

        serializedObject.ApplyModifiedProperties();
    }
}


===== PARTICLE =====

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class ParticleBehaviour : MonoBehaviour
{
    public float minLifetime;
    public float maxLifetime;
    public float minSize;
    public float maxSize;
    public float radius;
    public enum SpriteLife {
        Distance,
        Time
    }
    public SpriteLife spriteLife;
    public float distanceThreshold;

    public enum Movement {
        Straight,
        UpWind,
        Tornado,
        Firework
    }
    public Movement movType;

    // upwind values
    public float upwardForce;
    public float horizontalForce;
    // straight values
    public float minSpeed;
    public float maxSpeed;
    // tornado values
    private float tornadoRadius;
    public float tornadoHeight;
    public float minRotationSpeed;
    public float maxRotationSpeed;
    public float minTornadoRadius;
    public float maxTornadoRadius;
    public float verticalSpeed;
    private float rotationSpeed;
    private float rotationAngle;

    // private
    private Vector3 velocity;
    private Vector3 startPos;
    private float lifetime;
    private float age;
    private float distance;

    public enum Rendering {
        ColourChange,
        SpriteSheet
    }
    public bool defineColour;
    public Color startColour;
    public Color endColour;
    private SpriteRenderer image;
    public Sprite[] sprites;
    private int currentSpriteIndex;
    public enum BlendType {
        None,
        Additive,
        Multiplicative
    }
    public BlendType blendType;
    
    // Start is called before the first frame update
    public void Initialize(Vector3 position, Vector3 decidedVelocity) {
        this.startPos = position;
        transform.position = position;
        transform.localScale = 0.1f * Random.Range(minSize, maxSize)*Vector3.one;
        switch(movType) {
            case Movement.Straight:
                float straightSpeed = Random.Range(minSpeed, maxSpeed);
                this.velocity = Random.insideUnitSphere*straightSpeed;
                break;
            case Movement.UpWind:
                this.velocity = Vector3.zero;
                break;
            case Movement.Tornado:
                this.velocity = Vector3.zero;
                this.rotationSpeed = Random.Range(minRotationSpeed, maxRotationSpeed);
                this.rotationAngle = 0f;
                this.tornadoRadius = Random.Range(minTornadoRadius, maxTornadoRadius);
                transform.localScale = 0.1f * minSize*Vector3.one;
                break;
            case Movement.Firework:
                float speed = Random.Range(minSpeed, maxSpeed);
                this.velocity = decidedVelocity*speed;
                break;

        }
        this.lifetime = Random.Range(minLifetime, maxLifetime);
        this.age = 0f;
        this.GetComponent<SpriteRenderer>().sprite = sprites[0];
        if (defineColour) this.GetComponent<SpriteRenderer>().color = startColour;
        this.image = GetComponent<SpriteRenderer>();
        this.currentSpriteIndex = 0;
        this.radius = Mathf.Max(image.bounds.size.x, image.bounds.size.y) * 0.5f;
    }

    public void Blend(ParticleBehaviour other, float blendAmount) {
        Color color = this.image.color;
        switch (blendType) {
            case BlendType.None:
            break;
            case BlendType.Additive:
                color += other.image.color * blendAmount;
                break;
            case BlendType.Multiplicative:
                color *= Color.Lerp(Color.white, other.image.color, blendAmount);
                break;
    }
    this.image.color = color;
    }
    void Start()
    { 
    }

    // Update is called once per frame
    public void Update()
    {
        this.age += Time.deltaTime;
        this.distance = Vector3.Distance(this.startPos, this.transform.position);

        if (this.age <= this.lifetime) {
            
            // velocity determined for forces acting on the particle
            switch (movType) {
                case Movement.UpWind:
                    velocity += upwardForce * 0.001f * Vector3.up;
                    velocity += horizontalForce * 0.01f * new Vector3(Random.Range(-1f, 1f), 0f, Random.Range(-1f, 1f)).normalized;
                    transform.position += this.velocity*Time.deltaTime;
                    break;
                case Movement.Straight:
                    transform.position += this.velocity* Time.deltaTime;
                    break;
                case Movement.Tornado:
                    rotationAngle += rotationSpeed * Time.deltaTime;
                    float verticalDistance = Mathf.Clamp01(Mathf.Abs(transform.position.y-startPos.y)/(tornadoHeight*0.7f));
                    transform.localScale = 0.1f * Mathf.Lerp(minSize, maxSize, verticalDistance)*Vector3.one;
                    float radiusOffset = Mathf.Lerp(0f, tornadoRadius, verticalDistance);
                    float newX = Mathf.Cos(rotationAngle) * radiusOffset;
                    float newZ = Mathf.Sin(rotationAngle) * radiusOffset;
                    float newY = Mathf.Lerp(0f, tornadoHeight, age/lifetime);
                    transform.position = startPos + new Vector3(newX, newY, newZ);
                    break;
                case Movement.Firework:
                    float normalLife = (age*0.3f) / lifetime;
                    float fallSpeed = Mathf.Lerp(0f, 2f, normalLife);
                    velocity += fallSpeed * Vector3.down;
                    transform.position += this.velocity* Time.deltaTime;
                    break;
            }

            transform.LookAt(Camera.main.transform);
            transform.Rotate(0, 180, 0);

            // determining look (sprite/colour) of the particle
            float alphaRatio = 1f;
            Color color = this.image.color;
            // aging depends on which ratio is chosen
            float lifeRatio = 1;
            switch (spriteLife) {
                case SpriteLife.Distance:
                    lifeRatio = distance/distanceThreshold;
                break;
                case SpriteLife.Time:
                    lifeRatio = age/lifetime;
                break;
            }
            if (defineColour) color = Color.Lerp(startColour, endColour, lifeRatio);
            int nextSpriteIndex = Mathf.Clamp(Mathf.FloorToInt(lifeRatio * sprites.Length), 0, sprites.Length-1);
                    if (nextSpriteIndex != currentSpriteIndex) {
                        currentSpriteIndex = nextSpriteIndex;
                        image.sprite = sprites[currentSpriteIndex];
                    }
            if (lifeRatio > 0.7f) {
                    alphaRatio = Mathf.Clamp01((lifeRatio - age)/(lifeRatio * 0.3f));
            }
            color.a *= alphaRatio;           
            this.image.color = color;
        }
        else {Destroy(gameObject);}
    }
}


===== PARTICLE UNITY EDITOR =====


using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class SystemSpawnBehaviour : MonoBehaviour
{
    public GameObject systemPrefab;
    public float frequency;
    public float height;
    public float width;
    public enum AlongAxis {
        X,
        Z
    }
    public AlongAxis alongAxis;
    private Vector3 leftDownCorner;
    private Vector3 rightDownCorner;
    private Vector3 leftUpCorner;
    private Vector3 rightUpCorner;
    public GameObject[] particles;


    private ParticleSystemBehaviour createSystem(Vector3 position, GameObject particle) {
        ParticleSystemBehaviour newSystem = Instantiate(systemPrefab, position, Quaternion.identity).GetComponent<ParticleSystemBehaviour>();
        newSystem.Initialize(position, particle);
        aliveSystems.Add(newSystem);
        return newSystem;
    }

    private List<ParticleSystemBehaviour> aliveSystems = new List<ParticleSystemBehaviour>();
    private float frequency_timer = 0f;
    // Start is called before the first frame update
    void Start()
    {
        if (alongAxis == AlongAxis.Z) {
            leftDownCorner = new Vector3(transform.position.x, transform.position.y - height, transform.position.z - width);
            rightDownCorner = new Vector3(transform.position.x, transform.position.y - height, transform.position.z + width);
            rightUpCorner = new Vector3(transform.position.x, transform.position.y + height, transform.position.z + width);
            leftUpCorner = new Vector3(transform.position.x, transform.position.y + height, transform.position.z - width);
        } else {
            leftDownCorner = new Vector3(transform.position.x - width, transform.position.y - height, transform.position.z);
            rightDownCorner = new Vector3(transform.position.x + width, transform.position.y - height, transform.position.z);
            rightUpCorner = new Vector3(transform.position.x + width, transform.position.y + height, transform.position.z);
            leftUpCorner = new Vector3(transform.position.x - width, transform.position.y + height, transform.position.z);
        }
    }

    // Update is called once per frame
    void Update()
    {
        frequency_timer += Time.deltaTime;
        if (frequency_timer >= frequency) {
            float rdmLength = Random.Range(0f, 1f);
            float rdmHeight = Random.Range(0f, 1f);
            Vector3 randomPos = leftDownCorner + rdmLength * (rightDownCorner - leftDownCorner) + rdmHeight * (leftUpCorner - leftDownCorner);
            
            int rdmIndex = Random.Range(0, particles.Length);
            createSystem(randomPos, particles[rdmIndex]);
            frequency_timer = 0f;
        }
        removeDeadSystems();
        updateAliveSystems();
    }

    private void removeDeadSystems() {
        aliveSystems.RemoveAll(system => system == null);
    }

    private void updateAliveSystems() {
        for (int i = 0; i < aliveSystems.Count; i++) {
            ParticleSystemBehaviour system = aliveSystems[i];
            system.Update();
        }
    }
}

===== PARTICLE SYSTEM SPAWNER =====
